diff --git a/node_modules/acorn-node/lib/private-class-elements/index.js b/node_modules/acorn-node/lib/private-class-elements/index.js
index 364e1fc..f15d976 100644
--- a/node_modules/acorn-node/lib/private-class-elements/index.js
+++ b/node_modules/acorn-node/lib/private-class-elements/index.js
@@ -35,7 +35,7 @@ module.exports = function(Parser) {
     Parser_.prototype.constructor = Parser_;
 
     Parser_.prototype._branch = function _branch () {
-      this.__branch = this.__branch || new Parser({ecmaVersion: this.options.ecmaVersion}, this.input)
+      this.__branch = this.__branch || new Parser_({ecmaVersion: this.options.ecmaVersion}, this.input)
       this.__branch.end = this.end
       this.__branch.pos = this.pos
       this.__branch.type = this.type
diff --git a/node_modules/acorn-node/lib/static-class-features/index.js b/node_modules/acorn-node/lib/static-class-features/index.js
index 3894491..2a93614 100644
--- a/node_modules/acorn-node/lib/static-class-features/index.js
+++ b/node_modules/acorn-node/lib/static-class-features/index.js
@@ -2,25 +2,14 @@
 
 "use strict"
 
-var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g
-
-var acorn = require("acorn")
-var tt = acorn.tokTypes
-
-function maybeParseFieldValue(field) {
-  if (this.eat(tt.eq)) {
-    var oldInFieldValue = this._inStaticFieldValue
-    this._inStaticFieldValue = true
-    field.value = this.parseExpression()
-    this._inStaticFieldValue = oldInFieldValue
-  } else { field.value = null }
-}
-
 var privateClassElements = require("../private-class-elements")
 
 module.exports = function(Parser) {
   var ExtendedParser = privateClassElements(Parser)
 
+  var acorn = Parser.acorn || require("acorn")
+  var tt = acorn.tokTypes
+
   return /*@__PURE__*/(function (ExtendedParser) {
     function anonymous () {
       ExtendedParser.apply(this, arguments);
@@ -30,107 +19,74 @@ module.exports = function(Parser) {
     anonymous.prototype = Object.create( ExtendedParser && ExtendedParser.prototype );
     anonymous.prototype.constructor = anonymous;
 
-    anonymous.prototype.parseClassElement = function parseClassElement (_constructorAllowsSuper) {
-      var this$1 = this;
-
-      if (this.eat(tt.semi)) { return null }
-
-      var node = this.startNode()
+    anonymous.prototype._maybeParseFieldValue = function _maybeParseFieldValue (field) {
+      if (this.eat(tt.eq)) {
+        var oldInFieldValue = this._inStaticFieldScope
+        this._inStaticFieldScope = this.currentThisScope()
+        field.value = this.parseExpression()
+        this._inStaticFieldScope = oldInFieldValue
+      } else { field.value = null }
+    };
 
-      var tryContextual = function (k, noLineBreak) {
-        if (typeof noLineBreak == "undefined") { noLineBreak = false }
-        var start = this$1.start, startLoc = this$1.startLoc
-        if (!this$1.eatContextual(k)) { return false }
-        if (this$1.type !== tt.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
-        if (node.key) { this$1.unexpected() }
-        node.computed = false
-        node.key = this$1.startNodeAt(start, startLoc)
-        node.key.name = k
-        this$1.finishNode(node.key, "Identifier")
-        return false
+    // Parse fields
+    anonymous.prototype.parseClassElement = function parseClassElement (_constructorAllowsSuper) {
+      if (this.options.ecmaVersion < 8 || !this.isContextual("static")) {
+        return ExtendedParser.prototype.parseClassElement.apply(this, arguments)
       }
 
-      node.static = tryContextual("static")
-      if (!node.static) { return ExtendedParser.prototype.parseClassElement.apply(this, arguments) }
-
-      var isGenerator = this.eat(tt.star)
-      var isAsync = false
-      if (!isGenerator) {
-        // Special-case for `async`, since `parseClassMember` currently looks
-        // for `(` to determine whether `async` is a method name
-        if (this.options.ecmaVersion >= 8 && this.isContextual("async")) {
-          skipWhiteSpace.lastIndex = this.pos
-          var skip = skipWhiteSpace.exec(this.input)
-          var next = this.input.charAt(this.pos + skip[0].length)
-          if (next === ";" || next === "=") {
-            node.key = this.parseIdent(true)
-            node.computed = false
-            maybeParseFieldValue.call(this, node)
-            this.finishNode(node, "FieldDefinition")
-            this.semicolon()
-            return node
-          } else if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
-            isAsync = true
-            isGenerator = this.options.ecmaVersion >= 9 && this.eat(tt.star)
-          }
-        } else if (tryContextual("get")) {
-          node.kind = "get"
-        } else if (tryContextual("set")) {
-          node.kind = "set"
-        }
+      var branch = this._branch()
+      branch.next()
+      if ([tt.name, tt.bracketL, tt.string, tt.num, this.privateNameToken].indexOf(branch.type) == -1) {
+        return ExtendedParser.prototype.parseClassElement.apply(this, arguments)
+      }
+      if (branch.type == tt.bracketL) {
+        var count = 0
+        do {
+          if (branch.eat(tt.bracketL)) { ++count }
+          else if (branch.eat(tt.bracketR)) { --count }
+          else { branch.next() }
+        } while (count > 0)
+      } else { branch.next() }
+      if (branch.type != tt.eq && !branch.canInsertSemicolon() && branch.type != tt.semi) {
+        return ExtendedParser.prototype.parseClassElement.apply(this, arguments)
       }
-      if (this.type === this.privateNameToken) {
+
+      var node = this.startNode()
+      node.static = this.eatContextual("static")
+      if (this.type == this.privateNameToken) {
         this.parsePrivateClassElementName(node)
-        if (this.type !== tt.parenL) {
-          if (node.key.name === "prototype") {
-            this.raise(node.key.start, "Classes may not have a private static property named prototype")
-          }
-          maybeParseFieldValue.call(this, node)
-          this.finishNode(node, "FieldDefinition")
-          this.semicolon()
-          return node
-        }
-      } else if (!node.key) {
+      } else {
         this.parsePropertyName(node)
-        if ((node.key.name || node.key.value) === "prototype" && !node.computed) {
-          this.raise(node.key.start, "Classes may not have a static property named prototype")
-        }
-      }
-      if (!node.kind) { node.kind = "method" }
-      this.parseClassMethod(node, isGenerator, isAsync)
-      if (!node.kind && (node.key.name || node.key.value) === "constructor" && !node.computed) {
-        this.raise(node.key.start, "Classes may not have a static field named constructor")
       }
-      if (node.kind === "get" && node.value.params.length !== 0) {
-        this.raiseRecoverable(node.value.start, "getter should have no params")
+      if ((node.key.type === "Identifier" && node.key.name === "constructor") ||
+          (node.key.type === "Literal" && !node.computed && node.key.value === "constructor")) {
+        this.raise(node.key.start, "Classes may not have a field called constructor")
       }
-      if (node.kind === "set" && node.value.params.length !== 1) {
-        this.raiseRecoverable(node.value.start, "setter should have exactly one param")
-      }
-      if (node.kind === "set" && node.value.params[0].type === "RestElement") {
-        this.raiseRecoverable(node.value.params[0].start, "Setter cannot use rest params")
+      if ((node.key.name || node.key.value) === "prototype" && !node.computed) {
+        this.raise(node.key.start, "Classes may not have a static property named prototype")
       }
 
+      this._maybeParseFieldValue(node)
+      this.finishNode(node, "FieldDefinition")
+      this.semicolon()
       return node
-
     };
 
-    // Parse public static fields
-    anonymous.prototype.parseClassMethod = function parseClassMethod (method, isGenerator, isAsync, _allowsDirectSuper) {
-      if (isGenerator || isAsync || method.kind != "method" || !method.static || this.options.ecmaVersion < 8 || this.type == tt.parenL) {
-        return ExtendedParser.prototype.parseClassMethod.apply(this, arguments)
+    // Parse private static methods
+    anonymous.prototype.parsePropertyName = function parsePropertyName (prop) {
+      if (prop.static && this.type == this.privateNameToken) {
+        this.parsePrivateClassElementName(prop)
+      } else {
+        ExtendedParser.prototype.parsePropertyName.call(this, prop)
       }
-      maybeParseFieldValue.call(this, method)
-      delete method.kind
-      method = this.finishNode(method, "FieldDefinition")
-      this.semicolon()
-      return method
     };
 
     // Prohibit arguments in class field initializers
     anonymous.prototype.parseIdent = function parseIdent (liberal, isBinding) {
       var ident = ExtendedParser.prototype.parseIdent.call(this, liberal, isBinding)
-      if (this._inStaticFieldValue && ident.name == "arguments") { this.raise(ident.start, "A static class field initializer may not contain arguments") }
+      if (this._inStaticFieldScope && this.currentThisScope() === this._inStaticFieldScope && ident.name == "arguments") {
+        this.raise(ident.start, "A static class field initializer may not contain arguments")
+      }
       return ident
     };
 
